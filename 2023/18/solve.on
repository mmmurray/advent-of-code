let vec2Scale = (scale: i32, v: Vec2): Vec2 -> {
  return Vec2 {
    x: (* v.x scale),
    y: (* v.y scale),
  }
}

data Direction =
  | North {}
  | East {}
  | South {}
  | West {}

let directionNorth = North {}
let directionEast = East {}
let directionSouth = South {}
let directionWest = West {}

let vec2North = Vec2 { x: 0, y: (- 0 1) }
let vec2East = Vec2 { x: 1, y: 0 }
let vec2South = Vec2 { x: 0, y: 1 }
let vec2West = Vec2 { x: (- 0 1), y: 0 }

let directionToVec2 = (direction: Direction): Vec2 -> {
  return match direction {
    North -> vec2North;
    East -> vec2East;
    South -> vec2South;
    West -> vec2West;
  }
}

data Step {
  direction: Direction,
  distance: i32,
  color: String,
}

let parseDirection = (input: String): Direction -> {
  let char = (stringGet input 0)
  if (== char 'U') {
    return directionNorth
  }
  if (== char 'R') {
    return directionEast
  }
  if (== char 'D') {
    return directionSouth
  }
  if (== char 'L') {
    return directionWest
  }
}

let parseInput = (input: String): List<Step> -> {
  let lines = (stringToLines (stringTrim input))
  let steps = (listCreateDefault<Step>)

  for line in lines {
    let parts = (stringSplitBy line ' ')
    let direction = (parseDirection (listGet parts 0))
    let distance = (stringToNumber (listGet parts 1))
    let color = (listGet parts 2)
    let step = Step {
      direction: direction,
      distance: distance,
      color: color,
    }
    (listPush steps step)
  }

  return steps
}

data Grid {
  size: Vec2,
  tiles: List< List<i32> >,
}

let infinity = 1000000000

let buidGridFromSteps = (steps: List<Step>): Grid -> {
  let minX = infinity
  let minY = infinity
  let maxX = (- 0 infinity)
  let maxY = (- 0 infinity)

  let position1 = Vec2 { x: 0, y: 0 }
  for step1 in steps {
    let delta = (vec2Scale step1.distance (directionToVec2 step1.direction))
    position1 = (vec2Add position1 delta)
    minX = (min minX position1.x)
    minY = (min minY position1.y)
    maxX = (max maxX position1.x)
    maxY = (max maxY position1.y)
  }

  let offset = Vec2 { x: (- 1 minX), y: (- 1 minY) }
  let position2 = Vec2 { x: 0, y: 0 }
  let boundaryPositions = (listCreateDefault<Vec2>)
  for step2 in steps {
    let delta = (directionToVec2 step2.direction)
    let it = 0
    while (< it step2.distance) {
      position2 = (vec2Add position2 delta)
      (listPush boundaryPositions (vec2Add offset position2))
      it = (+ it 1)
    }
  }

  let size = Vec2 { x: (+ (- maxX minX) 3), y: (+ (- maxY minY) 3) }
  let tiles = (listCreateDefault< List<i32> )

  let y = 0
  while (< y size.y) {
    let x = 0
    let row = (listCreateDefault<i32>)
    while (< x size.x) {
      let tilePosition = Vec2 { x: x, y: y }
      let value = 0
      for boundaryPosition in boundaryPositions {
        if (vec2Equals tilePosition boundaryPosition) {
          value = 1
        }
      }
      (listPush row value)
      x = (+ x 1)
    }
    (listPush tiles row)
    y = (+ y 1)
  }

  return Grid {
    size: size,
    tiles: tiles,
  }
}

let printGrid = (grid: Grid): void -> {
  let size = grid.size
  let out = (stringBuilderCreate 1024)
  (stringBuilderAppend out "Size: ")
  (stringBuilderAppend out (vec2ToString size))
  (stringBuilderAppend out "\n")

  let y = 0
  while (< y size.y) {
    let x = 0
    while (< x size.x) {
      let position = Vec2 { x: x, y: y }
      let tile = (listGet (listGet grid.tiles y) x)

      if (== tile 2) {
        (stringBuilderAppend out "~")
      }
      if (== tile 1) {
        (stringBuilderAppend out "#")
      }
      if (== tile 0) {
        (stringBuilderAppend out ".")
      }
      x = (+ x 1)
    }
    (stringBuilderAppend out "\n")
    y = (+ y 1)
  }

  (print (stringBuilderBuild out))
}

let floodGrid = (grid: Grid, current: Vec2): i32 -> {
  let currentRow = (listGet grid.tiles current.y)
  let value = (listGet currentRow current.x)
  let size = grid.size

  if (!= value 0) {
    return 0
  }

  (listSet currentRow current.x 2)

  if (> current.y 0) {
    let candidate = Vec2 { x: current.x, y: (- current.y 1) }
    (floodGrid grid candidate)
  }

  if (< current.x (- size.x 1)) {
    let candidate = Vec2 { x: (+ current.x 1), y: current.y }
    (floodGrid grid candidate)
  }

  if (< current.y (- size.y 1)) {
    let candidate = Vec2 { x: current.x, y: (+ current.y 1) }
    (floodGrid grid candidate)
  }

  if (> current.x 0) {
    let candidate = Vec2 { x: (- current.x 1), y: current.y }
    (floodGrid grid candidate)
  }
  
  return 0
}

let solvePart1 = (input: String): String -> {
  let steps = (parseInput input)
  let grid = (buidGridFromSteps steps)
  (printGrid grid)

  (floodGrid grid Vec2 { x: 0, y: 0 })
  (printGrid grid)

  let size = grid.size
  let result = 0

  let y = 0
  while (< y size.y) {
    let x = 0
    while (< x size.x) {
      let value = (listGet (listGet grid.tiles y) x)
      if (!= value 2) {
        result = (+ result 1)
      }
      x = (+ x 1)
    }
    y = (+ y 1)
  }

  return (stringFromNumber result)
}

let main = (): void -> {
  let input = (fileRead "input.txt")

  let part1 = (solvePart1 input)
  (print "Part 1:")
  (print part1)
  (assertEqualString part1 "44436")

  # let part2 = (solvePart2 input)
  # (print "Part 2:")
  # (print part2)
  # (assertEqualString part2 "???")
}
