import { _type_Array, arrayCreate, arrayGet, arraySet } from "@array";
import { assertEqualString } from "@assert";
import { _type_List, listFromArray, listFromString, listGet, listPush, listRemove } from "@list";
import {
  stringEquals,
  stringFromNumber,
  stringGet,
  stringSize,
  stringSlice,
  stringSplitBy,
  stringToNumber,
  stringTrim,
} from "@string";
import { _type_String } from "@string-base";
import { getValue: getInput } from "./input.txt";

data Operation =
  | Insert {
      label: String,
      focalLength: i32,
    }
  | Remove {
      label: String,
    }

data Step = {
  raw: String,
  operation: Operation,
}

let parseOperation = (input: String): Operation -> {
  let lastChar = stringGet(input, (stringSize(input) - 1));

  return case {
    (lastChar == '-') -> {
      let label = stringSlice(input, 0, (stringSize(input) - 1));

      return Remove({ label: label });
    };
    true -> {
      let parts = stringSplitBy(input, '=');

      return Insert({
        label: listGet(parts, 0),
        focalLength: stringToNumber(listGet(parts, 1)),
      });
    };
  };
}

let parseInput = (input: String): List<Step> -> {
  let parts = stringSplitBy(stringTrim(input), ',');
  let steps = [];

  for part in parts {
    let step = Step({ raw: part, operation: parseOperation(part) });

    listPush(steps, step);
  }

  return steps;
}

let hash = (value: String): i32 -> {
  let result = 0;

  for char in listFromString(value) {
    result = (((result + char) * 17) % 256);
  }

  return result;
}

let solvePart1 = (input: String): String -> {
  let sequence = parseInput(input);
  let result = 0;

  for step in sequence {
    result = (result + hash(step.raw));
  }

  return stringFromNumber(result);
}

data Lens = {
  label: String,
  focalLength: i32,
}

data Box = {
  lenses: List<Lens>,
}

let solvePart2 = (input: String): String -> {
  let sequence = parseInput(input);
  let result = 0;
  let boxes = arrayCreate(256);

  for _, i in listFromArray(boxes) {
    let box = Box({ lenses: [] });

    arraySet(boxes, i, box);
  }

  for step in sequence {
    let stepOperation = step.operation;
    let stepLabel = match stepOperation {
      Insert { label } -> label;
      Remove { label } -> label;
    };
    let boxIndex = hash(stepLabel);
    let box = arrayGet(boxes, boxIndex);
    let _ = match stepOperation {
      Insert { label, focalLength } -> {
        let replaced = false;

        for lens, lensIndex in box.lenses {
          if stringEquals(lens.label, label) {
            lens.focalLength = focalLength;
            replaced = true;
          }
        }

        if !(replaced) {
          let lens = Lens({ label: label, focalLength: focalLength });

          listPush(box.lenses, lens);
        }
      };
      Remove { label } -> {
        let removeIndex = --(1);

        for lens, lensIndex in box.lenses {
          if stringEquals(lens.label, label) {
            removeIndex = lensIndex;
          }
        }

        if (removeIndex >= 0) {
          listRemove(box.lenses, removeIndex);
        }
      };
    };
  }

  for box, boxIndex in listFromArray(boxes) {
    for lens, lensIndex in box.lenses {
      let focussingPower = ((boxIndex + 1) * ((lensIndex + 1) * lens.focalLength));

      result = (result + focussingPower);
    }
  }

  return stringFromNumber(result);
}

let main = (): unit -> {
  let input = getInput();
  let part1 = solvePart1(input);

  assertEqualString(part1, "509152");

  let part2 = solvePart2(input);

  assertEqualString(part2, "244403");
}
