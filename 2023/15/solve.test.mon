import { Array, arrayCreate, arrayGet, arraySet } from "@array";
import { assertEqualString } from "@assert";
import { List, listFromArray } from "@list";
import {
  String,
  stringEquals,
  stringFromNumber,
  stringGet,
  stringSize,
  stringSlice,
  stringToArray,
  stringToNumber,
} from "@string";
import { getValue: getInput } from "./input.txt";

data Operation =
  | Insert {
      label: String,
      focalLength: i32,
    }
  | Remove {
      label: String,
    }

data Step = {
  raw: String,
  operation: Operation,
}

let parseOperation = (input: String): Operation -> {
  let lastChar = stringGet(input, (stringSize(input) - 1));

  case {
    (lastChar == '-') -> {
      let label = stringSlice(input, 0, (stringSize(input) - 1));

      Operation.Remove({ label: label })
    };
    _ -> {
      let parts = input.splitBy('=');

      Operation.Insert({ label: parts.get(0), focalLength: stringToNumber(parts.get(1)) })
    };
  }
}

let parseInput = (input: String): List<Step> -> {
  let parts = (input.trim()).splitBy(',');
  let steps = [];

  for part in parts {
    let step = Step.New({ raw: part, operation: parseOperation(part) });

    steps.push(step);
  }

  steps
}

let hash = (value: String): i32 -> {
  let result = 0;

  for char in listFromArray(stringToArray(value)) {
    result = (((result + char) * 17) % 256);
  }

  result
}

let solvePart1 = (input: String): String -> {
  let sequence = parseInput(input);
  let result = 0;

  for step in sequence {
    result = (result + hash(step.raw));
  }

  stringFromNumber(result)
}

data Lens = {
  label: String,
  focalLength: i32,
}

data Box = {
  lenses: List<Lens>,
}

let solvePart2 = (input: String): String -> {
  let sequence = parseInput(input);
  let result = 0;
  let boxes = arrayCreate(256);

  for _, i in listFromArray(boxes) {
    let box = Box.New({ lenses: [] });

    arraySet(boxes, i, box);
  }

  for step in sequence {
    let stepOperation = step.operation;
    let stepLabel = match stepOperation {
      Insert { label } -> label;
      Remove { label } -> label;
    };
    let boxIndex = hash(stepLabel);
    let box = arrayGet(boxes, boxIndex);
    let _ = match stepOperation {
      Insert { label, focalLength } -> {
        let replaced = false;

        for lens, lensIndex in box.lenses {
          if stringEquals(lens.label, label) {
            lens.focalLength = focalLength;
            replaced = true;
          }
        }

        if !(replaced) {
          let lens = Lens.New({ label: label, focalLength: focalLength });

          (box.lenses).push(lens);
        }
      };
      Remove { label } -> {
        let removeIndex = --(1);

        for lens, lensIndex in box.lenses {
          if stringEquals(lens.label, label) {
            removeIndex = lensIndex;
          }
        }

        if (removeIndex >= 0) {
          (box.lenses).remove(removeIndex);
        }
      };
    };
  }

  for box, boxIndex in listFromArray(boxes) {
    for lens, lensIndex in box.lenses {
      let focussingPower = ((boxIndex + 1) * ((lensIndex + 1) * lens.focalLength));

      result = (result + focussingPower);
    }
  }

  stringFromNumber(result)
}

let input = getInput();
let part1 = solvePart1(input);

assertEqualString(part1, "509152");

let part2 = solvePart2(input);

assertEqualString(part2, "244403");
