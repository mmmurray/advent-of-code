import { _type_Array, arrayCreate, arrayGet, arraySet } from "@array";
import { assertEqual, assertEqualString } from "@assert";
import { fileRead, print } from "@io";
import {
  _type_List,
  listClone,
  listFromArray,
  listFromString,
  listGet,
  listPop,
  listPush,
  listPushList,
  listRemove,
  listSet,
  listShift,
  listSize,
  listSlice,
} from "@list";
import { _type_Map, mapCreate, mapEntries, mapGet, mapSet, mapSize } from "@map";
import {
  Mat2,
  Vec2,
  _type_Mat2,
  _type_Vec2,
  lcmMany,
  mat2Determinant,
  max,
  min,
  vec2Add,
  vec2Equals,
  vec2IsAdjacent,
  vec2ManhattanDistance,
  vec2Scale,
} from "@math";
import { None, Some, _type_Option, optionValue } from "@option";
import { _type_Range, rangeCreate, rangeEmpty, rangeIntersect, rangeShift } from "@range";
import {
  charIsNumeric,
  charToString,
  stringBuilderAppend,
  stringBuilderBuild,
  stringBuilderCreate,
  stringConcat,
  stringContains,
  stringContainsAt,
  stringEquals,
  stringFromNumber,
  stringGet,
  stringSize,
  stringSlice,
  stringSplitBy,
  stringToLines,
  stringToNumber,
  stringToNumberI64,
  stringToNumberU64,
  stringToUpper,
  stringTrim,
} from "@string";
import { _type_String } from "@string-base";

let optionExpect = <T>(option: Option<T>): T -> {
  return match option {
    Some { value } -> value;
    None -> (@T 0);
  };
}

data Rating = {
  x: i32,
  m: i32,
  a: i32,
  s: i32,
}

data Condition = {
  property: i32,
  operator: i32,
  value: i32,
}

data WorkflowStep =
  | WorkflowStep {
      target: String,
    }
  | WorkflowStepConditional {
      target: String,
      condition: Condition,
    }

data Workflow = {
  name: String,
  steps: List<WorkflowStep>,
}

data System = {
  ratings: List<Rating>,
  workflows: Map<Workflow>,
}

let parseWorkflow = (input: String): Workflow -> {
  let workflowParts = (stringSplitBy input '{');
  let name = (listGet workflowParts 0);
  let innerPart = (listGet workflowParts 1);
  let inner = (stringSlice innerPart 0 (- (stringSize innerPart) 1));
  let steps = [];
  let stepParts = (stringSplitBy inner ',');

  for stepPart in stepParts {
    if (stringContains stepPart ":") {
      let conditionParts = (stringSplitBy stepPart ':');
      let conditionPart = (listGet conditionParts 0);
      let target = (listGet conditionParts 1);
      let step = (WorkflowStepConditional {
        target: target,
        condition: (Condition {
          property: (stringGet conditionPart 0),
          operator: (stringGet conditionPart 1),
          value: (stringToNumber (stringSlice conditionPart 2 (stringSize conditionPart))),
        }),
      });

      (listPush steps step);
    } else {
      let step2 = (WorkflowStep { target: stepPart });

      (listPush steps step2);
    }
  }

  return (Workflow { name: name, steps: steps });
}

let parseRating = (input: String): Rating -> {
  let rating = (Rating { x: 0, m: 0, a: 0, s: 0 });
  let inner = (stringSlice input 1 (- (stringSize input) 1));
  let ratingParts = (stringSplitBy inner ',');

  for ratingPart in ratingParts {
    let propertyParts = (stringSplitBy ratingPart '=');
    let propertyName = (listGet propertyParts 0);
    let propertyValue = (stringToNumber (listGet propertyParts 1));

    if (stringEquals propertyName "x") {
      rating.x = propertyValue;
    }

    if (stringEquals propertyName "m") {
      rating.m = propertyValue;
    }

    if (stringEquals propertyName "a") {
      rating.a = propertyValue;
    }

    if (stringEquals propertyName "s") {
      rating.s = propertyValue;
    }
  }

  return rating;
}

let parseInput = (input: String): System -> {
  let lines = (stringToLines (stringTrim input));
  let inWorkflowsSection = true;
  let workflows = (mapCreate);
  let ratings = [];

  for line in lines {
    if (== (stringSize line) 0) {
      inWorkflowsSection = false;
    } else {
      if inWorkflowsSection {
        let workflow = (parseWorkflow line);

        (mapSet workflows workflow.name workflow);
      } else {
        (listPush ratings (parseRating line));
      }
    }
  }

  return (System { workflows: workflows, ratings: ratings });
}

let printSystem = (system: System): unit -> {
  let out = (stringBuilderCreate 1024);
  let workflows = system.workflows;

  for workflowItem in (mapEntries workflows) {
    let workflow = workflowItem.value;

    (stringBuilderAppend out workflow.name);
    (stringBuilderAppend out "{");

    for step, stepIndex in workflow.steps {
      if (> stepIndex 0) {
        (stringBuilderAppend out ",");
      }

      let m = match step {
        WorkflowStep { target } -> {
          (stringBuilderAppend out target);
        };
        WorkflowStepConditional { target, condition } -> {
          (stringBuilderAppend out (charToString condition.property));
          (stringBuilderAppend out (charToString condition.operator));
          (stringBuilderAppend out (stringFromNumber condition.value));
          (stringBuilderAppend out ":");
          (stringBuilderAppend out target);
        };
      };
    }

    (stringBuilderAppend out "}\n");
  }

  (stringBuilderAppend out "\n");

  for rating in system.ratings {
    (stringBuilderAppend out "{x=");
    (stringBuilderAppend out (stringFromNumber rating.x));
    (stringBuilderAppend out ",m=");
    (stringBuilderAppend out (stringFromNumber rating.m));
    (stringBuilderAppend out ",a=");
    (stringBuilderAppend out (stringFromNumber rating.a));
    (stringBuilderAppend out ",s=");
    (stringBuilderAppend out (stringFromNumber rating.s));
    (stringBuilderAppend out "}\n");
  }

  (print (stringBuilderBuild out));
}

let doesConditionApply = (condition: Condition, rating: Rating): boolean -> {
  let propertyValue = case {
    (== condition.property 'x') -> rating.x;
    (== condition.property 'm') -> rating.m;
    (== condition.property 'a') -> rating.a;
    true -> rating.s;
  };

  return case {
    (== condition.operator '>') -> (> propertyValue condition.value);
    true -> (< propertyValue condition.value);
  };
}

let isPartAccepted = (workflows: Map<Workflow>, rating: Rating): boolean -> {
  let currentWorkflow = "in";
  let result = false;
  let loop = true;

  while loop {
    # (print (stringConcat "currentWorkflow: " currentWorkflow))

    loop = case {
      (stringEquals currentWorkflow "A") -> {
        result = true;

        return false;
      };
      (stringEquals currentWorkflow "R") -> {
        result = false;

        return false;
      };
      true -> {
        let workflow = (optionExpect (mapGet workflows currentWorkflow));
        let loop = true;

        for step in workflow.steps {
          if loop {
            let accepted = false;
            let rejected = false;
            let continue = match step {
              WorkflowStep { target } -> {
                currentWorkflow = target;

                return false;
              };
              WorkflowStepConditional { target, condition } -> {
                let inner = true;

                if (doesConditionApply condition rating) {
                  currentWorkflow = target;
                  inner = false;
                }

                return inner;
              };
            };

            if (!continue) {
              loop = false;
            }
          }
        }

        return true;
      };
    };
  }

  return result;
}

let solvePart1 = (input: String): String -> {
  let system = (parseInput input);
  let result = 0;

  for rating in system.ratings {
    if (isPartAccepted system.workflows rating) {
      let sum = (+ rating.x (+ rating.m (+ rating.a rating.s)));

      result = (+ result sum);
    }
  }

  return (stringFromNumber result);
}

let main = (): unit -> {
  let input = (fileRead "input.txt");
  let part1 = (solvePart1 input);

  (print "Part 1:");
  (print part1);
  (assertEqualString part1 "287054");

  # let part2 = (solvePart2 input)
  # (print "Part 2:")
  # (print part2)
  # (assertEqualString part2 "???")
}
