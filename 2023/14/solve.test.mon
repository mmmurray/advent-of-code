import { assertEqualString } from "@assert";
import { List, listFromArray, listGet, listPush, listSet } from "@list";
import { Vec2 } from "@math";
import {
  String,
  stringFromNumber,
  stringGet,
  stringSize,
  stringToArray,
  stringToLines,
  stringTrim,
} from "@string";
import { getValue: getInput } from "./input.txt";

data Grid = {
  size: Vec2<i32>,
  cols: List<List<i32> >,
}

let parseInput = (input: String): Grid -> {
  let lines = stringToLines(stringTrim(input));
  let cols = [];
  let size = Vec2.New({ x: stringSize(listGet(lines, 0)), y: lines.size() });

  for _, colIndex in listFromArray(stringToArray(listGet(lines, 0))) {
    let col = [];

    for line in lines {
      listPush(col, stringGet(line, colIndex));
    }

    listPush(cols, col);
  }

  Grid.New({ size: size, cols: cols })
}

let tiltColumn = (col: List<i32>): List<i32> -> {
  let newCol = col.clone();
  let nextFreeIndex = 0;

  for tile, colIndex in col {
    if (tile == '#') {
      nextFreeIndex = (colIndex + 1);

      listSet(newCol, colIndex, '#');
    } else {
      if (tile == 'O') {
        listSet(newCol, colIndex, '.');
        listSet(newCol, nextFreeIndex, 'O');

        nextFreeIndex = (nextFreeIndex + 1);
      } else {
        listSet(newCol, colIndex, '.');
      }
    }
  }

  newCol
}

let tiltGrid = (grid: Grid): Grid -> {
  let newCols = [];

  for col in grid.cols {
    listPush(newCols, tiltColumn(col));
  }

  Grid.New({ size: grid.size, cols: newCols })
}

let calculateLoad = (grid: Grid): i32 -> {
  let totalLoad = 0;
  let size = grid.size;

  for col in grid.cols {
    for tile, rowIndex in col {
      if (tile == 'O') {
        totalLoad = (totalLoad + (size.y - rowIndex));
      }
    }
  }

  totalLoad
}

let rotateGridClockwise = (grid: Grid): Grid -> {
  let newCols = [];
  let size = grid.size;
  let rowIndex = (size.y - 1);

  while (rowIndex >= 0) {
    let newCol = [];

    for col, colIndex in grid.cols {
      listPush(newCol, listGet(col, rowIndex));
    }

    listPush(newCols, newCol);

    rowIndex = (rowIndex - 1);
  }

  Grid.New({ size: size, cols: newCols })
}

let performSpinCycle = (grid: Grid): Grid -> {
  grid = tiltGrid(grid);
  grid = rotateGridClockwise(grid);
  grid = tiltGrid(grid);
  grid = rotateGridClockwise(grid);
  grid = tiltGrid(grid);
  grid = rotateGridClockwise(grid);
  grid = tiltGrid(grid);
  grid = rotateGridClockwise(grid);

  grid
}

let areColsEqual = (a: List<i32>, b: List<i32>): boolean -> {
  let result = true;

  for v1, i in a {
    let v2 = listGet(b, i);

    if (v1 != v2) {
      result = false;
    }
  }

  result
}

let areGridsEqual = (a: Grid, b: Grid): boolean -> {
  let result = true;

  for c1, i in a.cols {
    let c2 = listGet(b.cols, i);

    if !(areColsEqual(c1, c2)) {
      result = false;
    }
  }

  result
}

let solvePart1 = (input: String): String -> {
  let grid = parseInput(input);
  let tiltedGrid = tiltGrid(grid);
  let result = calculateLoad(tiltedGrid);

  stringFromNumber(result)
}

let solvePart2 = (input: String): String -> {
  let grid = parseInput(input);
  let grids = [];
  let totalCycles = 1000000000;
  let cycleOffset = --(1);
  let i = 0;

  while ((cycleOffset < 0) && (i < totalCycles)) {
    grid = performSpinCycle(grid);

    for otherGrid, otherGridIndex in grids {
      if areGridsEqual(grid, otherGrid) {
        cycleOffset = otherGridIndex;
      }
    }

    if (cycleOffset < 0) {
      listPush(grids, grid);

      i = (i + 1);
    }
  }

  let cycleLength = (grids.size() - cycleOffset);
  let gridIndex = (cycleOffset + (((totalCycles - 1) - cycleOffset) % cycleLength));
  let result = calculateLoad(listGet(grids, gridIndex));

  stringFromNumber(result)
}

let input = getInput();
let part1 = solvePart1(input);

assertEqualString(part1, "109345");

let part2 = solvePart2(input);

assertEqualString(part2, "112452");
