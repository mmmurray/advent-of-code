import { assertEqualString } from "@assert";
import { List, listFromArray, listGet, listPush, listSet, listSize } from "@list";
import { Vec2, max, vec2Add } from "@math";
import {
  String,
  stringFromNumber,
  stringSize,
  stringToArray,
  stringToLines,
  stringTrim,
} from "@string";
import { getValue: getInput } from "./input.txt";

data Direction =
  | North {}
  | East {}
  | South {}
  | West {}

let directionEquals = (a: Direction, b: Direction): boolean -> {
  match a {
    North -> match b {
      North -> true;
      _ -> false;
    };
    East -> match b {
      East -> true;
      _ -> false;
    };
    South -> match b {
      South -> true;
      _ -> false;
    };
    West -> match b {
      West -> true;
      _ -> false;
    };
  }
}

let directionNorth = (): Direction -> Direction.North({})

let directionEast = (): Direction -> Direction.East({})

let directionSouth = (): Direction -> Direction.South({})

let directionWest = (): Direction -> Direction.West({})

let vec2North = (): Vec2<i32> -> Vec2.New({ x: 0, y: --(1) })

let vec2East = (): Vec2<i32> -> Vec2.New({ x: 1, y: 0 })

let vec2South = (): Vec2<i32> -> Vec2.New({ x: 0, y: 1 })

let vec2West = (): Vec2<i32> -> Vec2.New({ x: --(1), y: 0 })

let directionToVec2 = (direction: Direction): Vec2<i32> -> {
  match direction {
    North -> vec2North();
    East -> vec2East();
    South -> vec2South();
    West -> vec2West();
  }
}

data Tile =
  | Empty {}
  | ReflectForward {}
  | ReflectBackward {}
  | SplitHorizontal {}
  | SplitVertical {}

data Grid = {
  size: Vec2<i32>,
  tiles: List<List<Tile> >,
  energized: List<List<List<Direction> > >,
}

let gridClone = (grid: Grid): Grid -> {
  let newEnergized = [];

  for energizedRow in grid.energized {
    let newEnergizedRow = [];

    for x in energizedRow {
      listPush(newEnergizedRow, x.clone());
    }

    listPush(newEnergized, newEnergizedRow);
  }

  Grid.New({ size: grid.size, tiles: grid.tiles, energized: newEnergized })
}

let parseTile = (char: i32): Tile -> {
  case {
    (char == '/') -> Tile.ReflectForward({});
    (char == '\\') -> Tile.ReflectBackward({});
    (char == '-') -> Tile.SplitHorizontal({});
    (char == '|') -> Tile.SplitVertical({});
    _ -> Tile.Empty({});
  }
}

let parseInput = (input: String): Grid -> {
  let lines = stringToLines(stringTrim(input));
  let size = Vec2.New({ x: stringSize(listGet(lines, 0)), y: listSize(lines) });
  let tiles = [];
  let energized = [];

  for line in lines {
    let tileRow = [];
    let energizedRow = [];

    for char, x in listFromArray(stringToArray(line)) {
      listPush(tileRow, parseTile(char));
      listPush(energizedRow, []);
    }

    listPush(tiles, tileRow);
    listPush(energized, energizedRow);
  }

  Grid.New({ size: size, tiles: tiles, energized: energized })
}

let propagate = (grid: Grid, position: Vec2<i32>, direction: Direction): boolean -> {
  let size = grid.size;

  case {
    (position.x < 0) -> false;
    (position.y < 0) -> false;
    (position.x >= size.x) -> false;
    (position.y >= size.y) -> false;
    _ -> {
      let energizedRow = listGet(grid.energized, position.y);
      let currentEnergizedDirections = listGet(energizedRow, position.x);
      let isSameDirection = false;

      for currentEnergizedDirection in currentEnergizedDirections {
        if directionEquals(currentEnergizedDirection, direction) {
          isSameDirection = true;
        }
      }

      case {
        isSameDirection -> false;
        _ -> {
          listSet(energizedRow, position.x, [...currentEnergizedDirections, direction]);

          let tile = listGet(listGet(grid.tiles, position.y), position.x);
          let directionVec = directionToVec2(direction);
          let _ = match tile {
            Empty -> {
              propagate(grid, vec2Add(position, directionVec), direction);
            };
            ReflectForward -> {
              let _ = match direction {
                North -> {
                  propagate(grid, vec2Add(position, vec2East()), directionEast());
                };
                East -> {
                  propagate(grid, vec2Add(position, vec2North()), directionNorth());
                };
                South -> {
                  propagate(grid, vec2Add(position, vec2West()), directionWest());
                };
                West -> {
                  propagate(grid, vec2Add(position, vec2South()), directionSouth());
                };
              };
            };
            ReflectBackward -> {
              let _ = match direction {
                North -> {
                  propagate(grid, vec2Add(position, vec2West()), directionWest());
                };
                East -> {
                  propagate(grid, vec2Add(position, vec2South()), directionSouth());
                };
                South -> {
                  propagate(grid, vec2Add(position, vec2East()), directionEast());
                };
                West -> {
                  propagate(grid, vec2Add(position, vec2North()), directionNorth());
                };
              };
            };
            SplitHorizontal -> {
              let _ = match direction {
                North -> {
                  propagate(grid, vec2Add(position, vec2East()), directionEast());
                  propagate(grid, vec2Add(position, vec2West()), directionWest());
                };
                East -> {
                  propagate(grid, vec2Add(position, directionVec), direction);
                };
                South -> {
                  propagate(grid, vec2Add(position, vec2West()), directionWest());
                  propagate(grid, vec2Add(position, vec2East()), directionEast());
                };
                West -> {
                  propagate(grid, vec2Add(position, directionVec), direction);
                };
              };
            };
            SplitVertical -> {
              let _ = match direction {
                North -> {
                  propagate(grid, vec2Add(position, directionVec), direction);
                };
                East -> {
                  propagate(grid, vec2Add(position, vec2North()), directionNorth());
                  propagate(grid, vec2Add(position, vec2South()), directionSouth());
                };
                South -> {
                  propagate(grid, vec2Add(position, directionVec), direction);
                };
                West -> {
                  propagate(grid, vec2Add(position, vec2South()), directionSouth());
                  propagate(grid, vec2Add(position, vec2North()), directionNorth());
                };
              };
            };
          };

          false
        };
      }
    };
  }
}

let countEnergized = (grid: Grid, startPosition: Vec2<i32>, startDirection: Direction): i32 -> {
  let newGrid = gridClone(grid);

  propagate(newGrid, startPosition, startDirection);

  let total = 0;

  for row in newGrid.energized {
    for col in row {
      if (listSize(col) > 0) {
        total = (total + 1);
      }
    }
  }

  total
}

let solvePart1 = (input: String): String -> {
  let grid = parseInput(input);
  let result = countEnergized(grid, Vec2.New({ x: 0, y: 0 }), directionEast());

  stringFromNumber(result)
}

let solvePart2 = (input: String): String -> {
  let grid = parseInput(input);
  let size = grid.size;
  let result = 0;
  let offset = 0;

  while (offset < size.x) {
    result = max(result, countEnergized(grid, Vec2.New({ x: offset, y: 0 }), directionSouth()));
    result = max(result, countEnergized(grid, Vec2.New({ x: offset, y: (size.y - 1) }), directionNorth()));
    result = max(result, countEnergized(grid, Vec2.New({ x: 0, y: offset }), directionEast()));
    result = max(result, countEnergized(grid, Vec2.New({ x: (size.x - 1), y: offset }), directionWest()));
    offset = (offset + 1);
  }

  stringFromNumber(result)
}

let input = getInput();
let part1 = solvePart1(input);

assertEqualString(part1, "8034");

let part2 = solvePart2(input);

assertEqualString(part2, "8225");
