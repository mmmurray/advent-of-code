import { assertEqual } from "@assert";
import { List, listFromArray, listGet } from "@list";
import { Map, mapCreate } from "@map";
import { Vec2, vec2Equals } from "@math";
import { Option } from "@option";
import {
  String,
  stringFromNumber,
  stringSize,
  stringToArray,
  stringToLines,
  stringTrim,
} from "@string";
import { stringBuilderCreate } from "@string-builder";
import { getValue: getExample } from "./example.txt";

let optionExpect = <T>(option: Option<T>): T -> {
  match option {
    Some { value } -> value;
    None -> (@T 0);
  }
}

let vec2ToString = (v: Vec2<i32>): String -> {
  let out = stringBuilderCreate();

  out.append("[");
  out.append(stringFromNumber(v.x));
  out.append(", ");
  out.append(stringFromNumber(v.y));
  out.append("]");

  out.build()
}

data PriorityQueueHeapEntry<T> = {
  node: T,
  priority: i32,
}

data PriorityQueue<T> = {
  heap: List<PriorityQueueHeapEntry<T> >,
}

let priorityQueueCreate = <T>(): PriorityQueue<T> -> {
  PriorityQueue.New({ heap: [] })
}

let priorityQueueSize = <T>(queue: PriorityQueue<T>): i32 -> {
  (queue.heap).size()
}

let priorityQueueInsert = <T>(queue: PriorityQueue<T>, node: T, priority: i32): unit -> {
  let entry = PriorityQueueHeapEntry.New({ node: node, priority: priority });

  (queue.heap).push(entry);

  let currentIndex = ((queue.heap).size() - 1);
  let loop = true;

  while (loop && (currentIndex > 0)) {
    let parentIndex = (currentIndex / 2);
    let parent = listGet(queue.heap, parentIndex);
    let current = listGet(queue.heap, currentIndex);

    if (parent.priority > current.priority) {
      loop = false;
    } else {
      (queue.heap).set(parentIndex, current);
      (queue.heap).set(currentIndex, parent);

      currentIndex = parentIndex;
    }
  }
}

let priorityQueueNext = <T>(queue: PriorityQueue<T>): Option<T> -> {
  case {
    ((queue.heap).size() == 0) -> Option.None({});
    ((queue.heap).size() == 1) -> {
      match (queue.heap).shift() {
        Some { value } -> Option.Some({ value: value.node });
        None -> Option.None({});
      }
    };
    _ -> {
      let highestPriority = listGet(queue.heap, 0);

      (queue.heap).set(0, optionExpect((queue.heap).pop()));

      let currentIndex = 0;
      let loop = false;

      while loop {
        let leftChildIndex = ((currentIndex * 2) + 1);
        let rightChildIndex = ((currentIndex * 2) + 2);
        let current = listGet(queue.heap, currentIndex);
        let swapIndex = --(1);

        if (leftChildIndex < (queue.heap).size()) {
          let leftChild = listGet(queue.heap, leftChildIndex);

          if (leftChild.priority > current.priority) {
            swapIndex = leftChildIndex;
          }
        }

        if (rightChildIndex < (queue.heap).size()) {
          let leftChild = listGet(queue.heap, leftChildIndex);
          let rightChild = listGet(queue.heap, rightChildIndex);

          if (((swapIndex < 0) && (rightChild.priority > current.priority)) || ((swapIndex >= 0) && (rightChild.priority > leftChild.priority))) {
            swapIndex = rightChildIndex;
          }
        }

        if (swapIndex < 0) {
          loop = false;
        } else {
          (queue.heap).set(currentIndex, listGet(queue.heap, swapIndex));
          (queue.heap).set(swapIndex, current);

          currentIndex = swapIndex;
        }
      }

      Option.Some({ value: highestPriority.node })
    };
  }
}

let _testPriorityQueue = (): unit -> {
  let queue = priorityQueueCreate<i32>();

  assertEqual(priorityQueueSize(queue), 0);
  priorityQueueInsert(queue, 1, 10);
  priorityQueueInsert(queue, 2, 30);
  priorityQueueInsert(queue, 3, 20);
  priorityQueueInsert(queue, 4, 5);
  priorityQueueInsert(queue, 5, 50);
  assertEqual(priorityQueueSize(queue), 5);
  assertEqual((priorityQueueNext(queue)).value(0), 5);
  assertEqual(priorityQueueSize(queue), 4);
  assertEqual((priorityQueueNext(queue)).value(0), 2);
  assertEqual(priorityQueueSize(queue), 3);
  assertEqual((priorityQueueNext(queue)).value(0), 3);
  assertEqual(priorityQueueSize(queue), 2);
  assertEqual((priorityQueueNext(queue)).value(0), 1);
  assertEqual(priorityQueueSize(queue), 1);
  assertEqual((priorityQueueNext(queue)).value(0), 4);
  assertEqual(priorityQueueSize(queue), 0);
  assertEqual((priorityQueueNext(queue)).value(0), 0);
  assertEqual(priorityQueueSize(queue), 0);
}

data Grid = {
  size: Vec2<i32>,
  tiles: List<List<i32> >,
}

let parseInput = (input: String): Grid -> {
  let lines = stringToLines(stringTrim(input));
  let size = Vec2.New({ x: stringSize(listGet(lines, 0)), y: lines.size() });
  let tiles = [];

  for line in lines {
    let tileRow = [];

    for char in listFromArray(stringToArray(line)) {
      tileRow.push((char - '0'));
    }

    tiles.push(tileRow);
  }

  Grid.New({ size: size, tiles: tiles })
}

let gridAdjacent = (grid: Grid, position: Vec2<i32>): List<Vec2<i32> > -> {
  let adjacent = [];
  let size = grid.size;

  if (position.x < (size.x - 1)) {
    adjacent.push(Vec2.New({ x: (position.x + 1), y: position.y }));
  }

  if (position.y < (size.y - 1)) {
    adjacent.push(Vec2.New({ x: position.x, y: (position.y + 1) }));
  }

  if (position.x > 0) {
    adjacent.push(Vec2.New({ x: (position.x - 1), y: position.y }));
  }

  if (position.y > 0) {
    adjacent.push(Vec2.New({ x: position.x, y: (position.y - 1) }));
  }

  adjacent
}

let extractShortestPath = (cameFrom: Map<String, Vec2<i32> >, targetNode: Vec2<i32>): List<Vec2<i32> > -> {
  # (print "+ extractShortestPath")

  let path = [];
  let c = targetNode;

  # (print (vec2ToString c))

  path.push(c);

  let loop = true;

  while loop {
    let cameFromOption = cameFrom.get(vec2ToString(c));
    let done = match cameFromOption {
      Some -> false;
      None -> true;
    };

    if done {
      loop = false;
    } else {
      c = optionExpect(cameFromOption);

      path.push(c);

      # (print (vec2ToString c))
    }
  }

  # (print "- extractShortestPath")

  path
}

let exceedsSingleDirectionLimit = (path: List<Vec2<i32> >): boolean -> {
  # (print "exceedsSingleDirectionLimit")

  let limit = 5;
  let size = path.size();

  case {
    (size < limit) -> false;
    _ -> {
      let sameX = true;
      let sameY = true;
      let i = 0;
      let current = listGet(path, i);

      # (print (stringConcat "Current " (vec2ToString current)))

      i = (i + 1);

      while (i < limit) {
        let next = listGet(path, i);

        # (print (stringConcat "Next " (vec2ToString next)))

        if (next.x != current.x) {
          sameX = false;
        }

        if (next.y != current.y) {
          sameY = false;
        }

        current = next;
        i = (i + 1);
      }

      let result = (sameX || sameY);

      # (print (stringConcat "exceedsSingleDirectionLimit result: " (stringFromNumber result)))

      result
    };
  }
}

let solvePart1 = (input: String): String -> {
  let grid = parseInput(input);

  # (printGrid grid [])

  let size = grid.size;
  let startNode = Vec2.New({ x: 0, y: 0 });
  let targetNode = Vec2.New({ x: (size.x - 1), y: (size.y - 1) });
  let openSet = priorityQueueCreate();
  let cameFrom = mapCreate();
  let gScore = mapCreate();

  priorityQueueInsert(openSet, startNode, 0);
  gScore.set(vec2ToString(startNode), 0);

  let loop = true;

  while loop {
    # (print "~~ STEP ~~")

    let currentOption = priorityQueueNext(openSet);
    let done = match currentOption {
      Some -> false;
      None -> true;
    };

    if done {
      loop = false;
    } else {
      let current = optionExpect(currentOption);

      # (print (stringConcat "Current: " (vec2ToString current)))

      if vec2Equals(current, targetNode) {
        # (print "Reached target")

        loop = false;
      } else {
        let currentKey = vec2ToString(current);
        let currentShortestPath = extractShortestPath(cameFrom, current);

        # (printGrid grid currentShortestPath)

        for neighbor in gridAdjacent(grid, current) {
          let viable = true;

          for visited in currentShortestPath {
            if vec2Equals(visited, neighbor) {
              viable = false;
            }
          }

          if exceedsSingleDirectionLimit([...currentShortestPath, neighbor]) {
            viable = false;
          }

          if viable {
            # let reachedLimit = (exceedsSingleDirectionLimit [...currentShortestPath, neighbor])
            # (write (@i32 reachedLimit))
            # (print (stringConcat "Neighbor: " (vec2ToString neighbor)))

            let neighborKey = vec2ToString(neighbor);
            let distance = listGet(listGet(grid.tiles, neighbor.y), neighbor.x);

            if !(viable) {
              distance = (distance + 99999);
            }

            # (print (stringConcat "Distance: " (stringFromNumber distance)))

            let currentGScore = (gScore.get(currentKey)).value(10000);
            let tentativeGScore = (currentGScore + distance);
            let neighborGScore = (gScore.get(neighborKey)).value(10000);

            if (tentativeGScore < neighborGScore) {
              cameFrom.set(neighborKey, current);
              gScore.set(neighborKey, tentativeGScore);
              priorityQueueInsert(openSet, neighbor, --(tentativeGScore));
            }
          }
        }
      }
    }
  }

  let path = extractShortestPath(cameFrom, targetNode);

  # (printGrid grid path)

  let result = 0;

  for position in path {
    if !(vec2Equals(position, startNode)) {
      let weight = listGet(listGet(grid.tiles, position.y), position.x);

      # (print (stringConcat "Path " (stringConcat (vec2ToString position) (stringFromNumber weight))))

      result = (result + weight);
    }
  }

  stringFromNumber(result)
}

# (testPriorityQueue)

let input = getExample();
let _part1 = solvePart1(input);

# todo
# (assertEqualString part1 "102")
# todo
# let part2 = (solvePart2 input)
# (assertEqualString part2 "???")
