import { _type_Array, arrayCreate, arrayGet, arraySet } from "@array";
import { assertEqual, assertEqualString } from "@assert";
import {
  _type_List,
  listClone,
  listFromArray,
  listFromString,
  listGet,
  listPush,
  listSet,
  listSize,
  listSlice,
} from "@list";
import { stringFromNumber, stringSplitBy, stringToLines, stringToNumber, stringTrim } from "@string";
import { _type_String } from "@string-base";
import { getValue: getInput } from "./input.txt";

data Row = {
  conditions: List<i32>,
  damaged: List<i32>,
  damageTotal: i32,
}

let parseRow = (line: String): Row -> {
  let parts = stringSplitBy(line, ' ');
  let conditions = [];

  for char in listFromString(listGet(parts, 0)) {
    listPush(conditions, char);
  }

  let damaged = [];
  let damagedParts = stringSplitBy(listGet(parts, 1), ',');
  let damageTotal = 0;

  for damagedPart in damagedParts {
    let damage = stringToNumber(damagedPart);

    listPush(damaged, damage);

    damageTotal = (damageTotal + damage);
  }

  Row({ conditions: conditions, damaged: damaged, damageTotal: damageTotal })
}

let parseInput = (input: String): List<Row> -> {
  let lines = stringToLines(stringTrim(input));
  let rows = [];

  for line in lines {
    listPush(rows, parseRow(line));
  }

  rows
}

let cacheSpacing = (): i32 -> 30

let createCache = (): Array<i32> -> {
  let cache = arrayCreate((cacheSpacing() * (cacheSpacing() * cacheSpacing())));

  for _, i in listFromArray(cache) {
    arraySet(cache, i, --(1));
  }

  cache
}

let placeDamage = (conditions: List<i32>, offset: i32, width: i32): List<i32> -> {
  let newConditions = listClone(conditions);

  for condition, index in conditions {
    if (condition == '?') {
      listSet(newConditions, index, '.');
    }

    if (index >= offset) {
      listSet(newConditions, index, '#');
    }

    if (index >= (offset + width)) {
      listSet(newConditions, index, listGet(conditions, index));
    }
  }

  newConditions
}

let conditionsContainDot = (conditions: List<i32>): boolean -> {
  let result = false;

  for condition in conditions {
    if (condition == '.') {
      result = true;
    }
  }

  result
}

let isValidPlacement = (conditions: List<i32>, maxDamage: i32, offset: i32, width: i32): boolean -> {
  let prevIndex = (offset - 1);
  let nextIndex = (offset + width);

  case {
    ((offset + width) > listSize(conditions)) -> false;
    conditionsContainDot(listSlice(conditions, offset, (offset + width))) -> false;
    ((prevIndex >= 0) && (listGet(conditions, prevIndex) == '#')) -> false;
    ((nextIndex < (listSize(conditions) - 1)) && (listGet(conditions, nextIndex) == '#')) -> false;
    _ -> {
      let damageTotal = 0;

      for condition2 in placeDamage(conditions, offset, width) {
        if (condition2 == '#') {
          damageTotal = (damageTotal + 1);
        }
      }

      (damageTotal <= maxDamage)
    };
  }
}

let countArrangementsRec = (cache: Array<i32>, row: Row, offset: i32, damagedIndex: i32): i32 -> {
  let damageTotal = 0;

  for condition2 in row.conditions {
    if (condition2 == '#') {
      damageTotal = (damageTotal + 1);
    }
  }

  let cacheKey = (damagedIndex + ((cacheSpacing() * offset) + (damageTotal * (cacheSpacing() * cacheSpacing()))));
  let cached = arrayGet(cache, cacheKey);

  case {
    (cached >= 0) -> cached;
    (offset >= listSize(row.conditions)) -> 0;
    _ -> {
      let arrangements = 0;
      let damageWidth = listGet(row.damaged, damagedIndex);
      let valid = isValidPlacement(row.conditions, row.damageTotal, offset, damageWidth);

      if valid {
        let nextConditions = placeDamage(row.conditions, offset, damageWidth);
        let nextDamagedIndex = (damagedIndex + 1);
        let nextOffset = (offset + (damageWidth + 1));

        if (nextDamagedIndex < listSize(row.damaged)) {
          let newRow = Row({
            conditions: nextConditions,
            damaged: row.damaged,
            damageTotal: row.damageTotal,
          });

          arrangements = (arrangements + countArrangementsRec(cache, newRow, nextOffset, nextDamagedIndex));
        } else {
          arrangements = (arrangements + 1);
        }
      }

      arrangements = (arrangements + countArrangementsRec(cache, row, (offset + 1), damagedIndex));

      arraySet(cache, cacheKey, arrangements);

      arrangements
    };
  }
}

let countArrangements = (row: Row): i32 -> {
  countArrangementsRec(createCache(), row, 0, 0)
}

let unfoldRow = (row: Row): Row -> {
  Row({
    conditions: [
      ...row.conditions,
      '?',
      ...row.conditions,
      '?',
      ...row.conditions,
      '?',
      ...row.conditions,
      '?',
      ...row.conditions,
    ],
    damaged: [
      ...row.damaged,
      ...row.damaged,
      ...row.damaged,
      ...row.damaged,
      ...row.damaged,
    ],
    damageTotal: (row.damageTotal * 5),
  })
}

let unfoldRows = (rows: List<Row>): List<Row> -> {
  let newRows = [];

  for row in rows {
    listPush(newRows, unfoldRow(row));
  }

  newRows
}

let testCountArrangements = (): unit -> {
  assertEqual(countArrangements(parseRow("? 1")), 1);
  assertEqual(countArrangements(parseRow("?? 1")), 2);
  assertEqual(countArrangements(parseRow("??? 1")), 3);
  assertEqual(countArrangements(parseRow("??? 2")), 2);
  assertEqual(countArrangements(parseRow("??? 1,1")), 1);
  assertEqual(countArrangements(parseRow("??? 3")), 1);
  assertEqual(countArrangements(parseRow("??? 4")), 0);
  assertEqual(countArrangements(parseRow("#?? 1")), 1);
  assertEqual(countArrangements(parseRow("#?? 2")), 1);
  assertEqual(countArrangements(parseRow("#.. 2")), 0);
  assertEqual(countArrangements(parseRow("### 2")), 0);
  assertEqual(countArrangements(parseRow(".## 2")), 1);
  assertEqual(countArrangements(parseRow("?????#???? 2,1,1")), 11);
}

let solvePart1 = (input: String): String -> {
  let rows = parseInput(input);
  let result = 0;

  for row in rows {
    result = (result + countArrangements(row));
  }

  stringFromNumber(result)
}

let _solvePart2 = (input: String): String -> {
  let rows = unfoldRows(parseInput(input));
  let result = 0;

  for row in rows {
    result = (result + countArrangements(row));
  }

  stringFromNumber(result)
}

testCountArrangements();

let input = getInput();
let part1 = solvePart1(input);

assertEqualString(part1, "7204");

# todo
# let part2 = (solvePart2 input)
# (assertEqualString part2 "???")
