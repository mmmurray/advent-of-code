import { assert-equal } from "@assert";
import { grid, grid-compass-4, grid-from-string } from "@grid";
import { list } from "@list";
import { set, set-create } from "@set";
import { string } from "@string";
import { vec2, vec2-create } from "@vec2";
import { get-value: get-example } from "./example.txt";
import { get-value: get-input } from "./input.txt";

let flood-fill = (world: grid<i32, i32>, region-type: i32, acc: set<vec2<i32>>, position: vec2<i32>): set<vec2<i32>> -> {
  let type = world.get-safe(position.x, position.y).or(0);

  case {
    acc.contains(position) -> acc;
    type != region-type -> acc;
    _ -> grid-compass-4().reduce(acc.add(position), (acc2: set<vec2<i32>>, direction: vec2<i32>) -> {
      let next-position = position.add(direction);

      flood-fill(world, region-type, acc, next-position)
    });
  }
}

let get-regions = (input: string): list<set<vec2<i32>>> -> {
  let world = grid-from-string(input.trim());
  let regions = world.reduce([], (acc: list<set<vec2<i32>>>, type: i32, x: i32, y: i32) -> {
    let position = vec2-create(x, y);

    case {
      acc.some((region: set<vec2<i32>>) -> region.contains(position)) -> acc;
      _ -> acc.push(flood-fill(world, type, set-create(), position));
    }
  });

  regions
}

let get-region-perimeter = (region: set<vec2<i32>>): i32 -> {
  region.values().map((position: vec2<i32>) -> {
    let outside-face-count = grid-compass-4().map((direction: vec2<i32>) -> case {
      region.contains(position.add(direction)) -> 0;
      _ -> 1;
    }).sum();

    outside-face-count
  }).sum()
}

let solve-part-1 = (input: string): i32 -> {
  let regions = get-regions(input);
  let total-price = regions.map((region: set<vec2<i32>>) -> {
    let area = region.size();
    let perimeter = get-region-perimeter(region);

    area * perimeter
  }).sum();

  total-price
}

assert-equal(solve-part-1(get-example()), 1930);
assert-equal(solve-part-1(get-input()), 1352976);
