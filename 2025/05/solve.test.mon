import { assert-equal } from "@assert";
import { range, range-create, range-size, range-union, ranges-overlap } from "@range";
import { set, set-create } from "@set";
import { string } from "@string";
import { get-value: get-input } from "./input.txt";

type database = { available-ids: [u64], fresh-ranges: [range<u64>] }

let parse-input = (input: string): database -> {
  let sections = input.trim().split-by("\n\n");
  let fresh-ranges = sections.get(0).split-by-lines().map((line: string) -> {
    let parts = line.split-by("-");

    range-create(parts.get(0).to-u64(), parts.get(1).to-u64() + 1)
  });
  let available-ids = sections.get(1).split-by-lines().map((line: string) -> line.to-u64());

  { fresh-ranges, available-ids }
}

let add-to-range-set = (rs: set<range<u64>>, r: range<u64>): set<range<u64>> -> {
  match rs.values().find((other: range<u64>) -> ranges-overlap(r, other)) {
    some({ value }) -> add-to-range-set(rs.remove(value.second()), range-union(value.second(), r));
    _ -> rs.add(r);
  }
}

let solve-part-1 = (input: string): string -> {
  let db = parse-input(input);

  db.available-ids.filter((id: u64) -> db.fresh-ranges.some((r: range<u64>) -> r.contains(id))).size().to-string()
}

let solve-part-2 = (input: string): string -> {
  let db = parse-input(input);
  let rs = db.fresh-ranges.reduce(set-create(), add-to-range-set);

  rs.values().map((r: range<u64>) -> range-size(r)).sum().to-string()
}

assert-equal(solve-part-1(get-input()), "733");
assert-equal(solve-part-2(get-input()), "345821388687084");
